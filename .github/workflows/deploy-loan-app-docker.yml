name: Deploy Loan App via Docker

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  CONTAINER_NAME: "loan-app-service"
  HOST_PORT: 3000
  CONTAINER_PORT: 3000
  SERVER_ENV_FILE_PATH: /etc/loan-app-service/.env

jobs:
  build-and-push-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image_uri: ${{ steps.get-primary-tag.outputs.primary_tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set lowercase image name components
        run: |
          echo "IMAGE_OWNER_LC=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "IMAGE_REPO_NAME_LC=loan-calculator-app" >> $GITHUB_ENV
        shell: bash

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER_LC }}/${{ env.IMAGE_REPO_NAME_LC }}
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=latest,enable=${{ github.ref == format('refs/heads/{0}', 'main') }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./loan-calculator-app
          file: ./loan-calculator-app/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Pass the Public Key so it is baked into the frontend JS
          build-args: |
            NEXT_PUBLIC_VAPID_PUBLIC_KEY=${{ secrets.NEXT_PUBLIC_VAPID_PUBLIC_KEY }}

      - name: Get primary image tag
        id: get-primary-tag
        run: |
          PRIMARY_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)
          echo "primary_tag=$PRIMARY_TAG" >> $GITHUB_OUTPUT
        shell: bash

  deploy-to-server:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build-and-push-image
    environment: production

    steps:
      - name: Set up SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy via SSH
        env:
          TARGET_SSH_HOST: ${{ secrets.SSH_HOST }}
          TARGET_SSH_USER: ubuntu
          FULL_IMAGE_URI: ${{ needs.build-and-push-image.outputs.image_uri }}
          GHCR_PULL_TOKEN: ${{ secrets.GHCR_PULL_TOKEN }}
          GHCR_USERNAME: ${{ github.repository_owner }}
          # Existing Secrets
          PROD_POSTGRES_URL: ${{ secrets.PROD_POSTGRES_URL }}
          PROD_JWT_SECRET: ${{ secrets.PROD_JWT_SECRET }}
          # New Secrets for Push Notifications
          PROD_VAPID_PRIVATE_KEY: ${{ secrets.PROD_VAPID_PRIVATE_KEY }}
          PROD_VAPID_SUBJECT: ${{ secrets.PROD_VAPID_SUBJECT }}
          NEXT_PUBLIC_VAPID_PUBLIC_KEY: ${{ secrets.NEXT_PUBLIC_VAPID_PUBLIC_KEY }}
        run: |
          ssh-keyscan -H "${TARGET_SSH_HOST}" >> ~/.ssh/known_hosts

          ssh -o StrictHostKeyChecking=no "${TARGET_SSH_USER}@${TARGET_SSH_HOST}" << EOF
            set -ex

            # 1. Prepare Environment File
            sudo mkdir -p $(dirname "${{ env.SERVER_ENV_FILE_PATH }}")

            echo "POSTGRES_URL=${PROD_POSTGRES_URL}" | sudo tee "${{ env.SERVER_ENV_FILE_PATH }}" > /dev/null
            echo "JWT_SECRET=${PROD_JWT_SECRET}" | sudo tee -a "${{ env.SERVER_ENV_FILE_PATH }}" > /dev/null
            
            # Add Push Notification Keys
            echo "VAPID_PRIVATE_KEY=${PROD_VAPID_PRIVATE_KEY}" | sudo tee -a "${{ env.SERVER_ENV_FILE_PATH }}" > /dev/null
            echo "VAPID_SUBJECT=${PROD_VAPID_SUBJECT}" | sudo tee -a "${{ env.SERVER_ENV_FILE_PATH }}" > /dev/null
            echo "NEXT_PUBLIC_VAPID_PUBLIC_KEY=${NEXT_PUBLIC_VAPID_PUBLIC_KEY}" | sudo tee -a "${{ env.SERVER_ENV_FILE_PATH }}" > /dev/null
            
            sudo chown root:root "${{ env.SERVER_ENV_FILE_PATH }}"
            sudo chmod 600 "${{ env.SERVER_ENV_FILE_PATH }}"

            # 2. Login to Registry
            echo "${GHCR_PULL_TOKEN}" | sudo docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin

            # 3. FULL Database Migration
            # This script defines the ENTIRE schema (idempotently)
            echo "Running Full Database Migration..."
            sudo docker run --rm \
              --network host \
              -e POSTGRES_URL="${PROD_POSTGRES_URL}" \
              ${FULL_IMAGE_URI} \
              node -e '
                const { Pool } = require("pg");
                const pool = new Pool({ connectionString: process.env.POSTGRES_URL });

                const sql = \`
                  BEGIN;

                  -- 1. Users Table
                  CREATE TABLE IF NOT EXISTS users (
                      id SERIAL PRIMARY KEY,
                      username VARCHAR(255) UNIQUE NOT NULL,
                      password VARCHAR(255) NOT NULL,
                      last_ip VARCHAR(255)
                  );

                  -- 2. Rooms Table (Updated to include "name")
                  CREATE TABLE IF NOT EXISTS rooms (
                      id SERIAL PRIMARY KEY,
                      code VARCHAR(6) UNIQUE NOT NULL,
                      creator_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
                      name VARCHAR(255)
                  );

                  -- 3. Room Members Table
                  CREATE TABLE IF NOT EXISTS room_members (
                      id SERIAL PRIMARY KEY,
                      user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                      room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
                      UNIQUE(user_id, room_id)
                  );

                  -- 4. Entries Table
                  CREATE TABLE IF NOT EXISTS entries (
                      id SERIAL PRIMARY KEY,
                      room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
                      user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                      amount NUMERIC(10, 2) NOT NULL,
                      description VARCHAR(255) NOT NULL,
                      split_with_user_ids JSONB,
                      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                  );

                  -- 5. Push Subscriptions Table (NEW)
                  CREATE TABLE IF NOT EXISTS push_subscriptions (
                      id SERIAL PRIMARY KEY,
                      user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                      endpoint TEXT NOT NULL UNIQUE,
                      p256dh TEXT NOT NULL,
                      auth TEXT NOT NULL,
                      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                  );
                  CREATE INDEX IF NOT EXISTS idx_push_subs_user_id ON push_subscriptions(user_id);

                  COMMIT;
                \`;

                pool.query(sql)
                  .then(() => { console.log("Database schema synchronized successfully."); process.exit(0); })
                  .catch(e => { console.error("Database migration failed:", e); process.exit(1); });
              '

            # 4. Update Systemd Service
            echo "[Unit]" | sudo tee "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "Description=${{ env.CONTAINER_NAME }} Docker Container" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "Requires=docker.service" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "After=docker.service network.target" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "[Service]" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "Restart=always" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "RestartSec=10" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "ExecStartPre=-/usr/bin/docker stop ${{ env.CONTAINER_NAME }}" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "ExecStartPre=-/usr/bin/docker rm ${{ env.CONTAINER_NAME }}" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "ExecStartPre=/usr/bin/docker pull ${FULL_IMAGE_URI}" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "ExecStart=/usr/bin/docker run --rm --name ${{ env.CONTAINER_NAME }} --add-host=host.docker.internal:host-gateway -p \"${{ env.HOST_PORT }}:${{ env.CONTAINER_PORT }}\" --env-file \"${{ env.SERVER_ENV_FILE_PATH }}\" ${FULL_IMAGE_URI}" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "ExecStop=/usr/bin/docker stop ${{ env.CONTAINER_NAME }}" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "[Install]" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"
            echo "WantedBy=multi-user.target" | sudo tee -a "/etc/systemd/system/${{ env.CONTAINER_NAME }}.service"

            # 5. Restart Service
            sudo systemctl daemon-reload
            sudo systemctl enable "${{ env.CONTAINER_NAME }}.service"
            sudo systemctl restart "${{ env.CONTAINER_NAME }}.service"

            echo "Deployment finished."
          EOF