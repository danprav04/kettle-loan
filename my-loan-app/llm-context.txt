This file contains the combined source code for the project. Each file is separated by a header indicating its path.

--- FILE: .env.example ---

# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"
DATABASE_URL="postgres://avnadmin:AVNS_WC7sVPgG69xrpUocmLZ@pg-2a7579b1-cristout-daa2.g.aivencloud.com:10830/defaultdb?sslmode=require"
JWT_SECRET="your-super-secret-jwt-key"

--- FILE: app/[lang]/dashboard/page.tsx ---

import { redirect } from 'next/navigation';
import { verifyToken } from '@/lib/auth';
import DashboardClient from '@/components/DashboardClient';
import { BASE_URL } from '@/app/constants';
import { cookies } from 'next/headers';

async function getDashboardData() {
    const cookieHeader = cookies().toString();
    const res = await fetch(`${BASE_URL}/api/dashboard`, {
        headers: {
            'Cookie': cookieHeader
        },
        cache: 'no-store' 
    });

    if (!res.ok) {
       return null;
    }
    return res.json();
}

export default async function Dashboard({ params: { lang } }: { params: { lang: string } }) {
    const tokenPayload = await verifyToken();
    if (!tokenPayload) {
        redirect(`/${lang}`);
    }

    const data = await getDashboardData();
    
    if(!data) {
        return <div>Error loading data. Please try logging in again.</div>
    }

    return <DashboardClient initialData={data} lang={lang} />;
}

--- FILE: app/[lang]/layout.tsx ---

// FILE: app/[lang]/layout.tsx
import { NextIntlClientProvider } from 'next-intl';
import { getMessages } from 'next-intl/server';
import { ReactNode } from 'react';
import { notFound } from 'next/navigation';

// Define supported locales. This should align with your i18n.ts and middleware.ts configurations.
const supportedLocales = ['en', 'he', 'ru'];

export default async function LocaleLayout({
  children,
  params, // params is now a Promise
}: {
  children: ReactNode;
  params: Promise<{ lang: string }>; // Type annotation for params updated to Promise
}) {
  // In Next.js 15+, params is a Promise and must be awaited before accessing its properties.
  const resolvedParams = await params;
  const lang = resolvedParams.lang;

  // Validate the 'lang' parameter after awaiting and resolving params.
  if (!supportedLocales.includes(lang)) {
    console.warn(`LocaleLayout: Unsupported locale "${lang}" received from resolved params. Triggering notFound().`);
    notFound();
    // notFound() should abort rendering, but return null for type safety and as a fallback.
    return null;
  }

  let messages;
  try {
    // Attempt to fetch internationalization messages for the given language.
    messages = await getMessages({ locale: lang });
  } catch (error) {
    // Log any errors encountered during message fetching.
    console.error(`LocaleLayout: Error fetching messages for locale "${lang}":`, error);
    // If this error persists ("Couldn't find next-intl config file"),
    // it might be an issue beyond just params resolution, potentially related to
    // next-intl's interaction with Turbopack or path resolution for message files.
    notFound(); // If messages can't be loaded, treat as a page not found.
    return null;
  }
  
  // Ensure that 'messages' is a valid object before passing to the provider.
  if (typeof messages !== 'object' || messages === null) {
      console.error(`LocaleLayout: Messages for locale "${lang}" are not a valid object. This may indicate an issue with the i18n setup or message files.`);
      notFound();
      return null;
  }

  // Provide the locale and messages to client components via NextIntlClientProvider.
  return (
    <NextIntlClientProvider locale={lang} messages={messages}>
      <div className="bg-gray-100 min-h-screen">{children}</div>
    </NextIntlClientProvider>
  );
}

--- FILE: app/[lang]/page.tsx ---

import AuthForm from "@/components/AuthForm";
import { verifyToken } from "@/lib/auth";
import { redirect } from "next/navigation";

export default async function Home() {
    const token = await verifyToken();
    if(token) {
        redirect('/dashboard');
    }

    return (
        <main>
           <AuthForm />
        </main>
    );
}

--- FILE: app/api/auth/login/route.ts ---

import { PrismaClient } from '@prisma/client';
import { compare } from 'bcrypt';
import { sign } from 'jsonwebtoken';
import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { username, password } = await req.json();

    const user = await prisma.user.findUnique({ where: { username } });
    if (!user) {
      return NextResponse.json({ error: 'Invalid username or password' }, { status: 401 });
    }

    const isPasswordValid = await compare(password, user.password);
    if (!isPasswordValid) {
      return NextResponse.json({ error: 'Invalid username or password' }, { status: 401 });
    }

    const token = sign({ userId: user.id }, process.env.JWT_SECRET!, { expiresIn: '1d' });

    (await cookies()).set('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/',
    });

    return NextResponse.json({ message: 'Logged in successfully' });
  } catch (error) {
    return NextResponse.json({ error: 'Something went wrong' }, { status: 500 });
  }
}

--- FILE: app/api/auth/signup/route.ts ---

import { PrismaClient } from '@prisma/client';
import { hash } from 'bcrypt';
import { NextResponse } from 'next/server';
import { headers } from 'next/headers';

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { username, password } = await req.json();
    const ip = (await headers()).get('x-forwarded-for') || '127.0.0.1';

    const existingUserByIP = await prisma.user.findFirst({ where: { signupIP: ip } });
    if (existingUserByIP) {
      return NextResponse.json({ error: 'This IP address has already been used to sign up.' }, { status: 400 });
    }

    const existingUser = await prisma.user.findUnique({ where: { username } });
    if (existingUser) {
      return NextResponse.json({ error: 'User already exists.' }, { status: 400 });
    }

    const hashedPassword = await hash(password, 10);
    await prisma.user.create({
      data: {
        username,
        password: hashedPassword,
        signupIP: ip,
      },
    });

    return NextResponse.json({ message: 'User created successfully' }, { status: 201 });
  } catch (error) {
    return NextResponse.json({ error: 'Something went wrong' }, { status: 500 });
  }
}

--- FILE: app/api/dashboard/route.ts ---

import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth';

const prisma = new PrismaClient();

export async function GET() {
    const tokenPayload = await verifyToken();
    if (!tokenPayload) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = tokenPayload.userId;

    try {
        const user = await prisma.user.findUnique({
            where: { id: userId },
            include: {
                rooms: {
                    include: {
                        room: {
                            include: {
                                users: {
                                    include: {
                                        user: {
                                            select: { id: true, username: true }
                                        }
                                    }
                                },
                                entries: {
                                    include: {
                                        user: {
                                            select: { id: true, username: true }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });

        if (!user) {
            return NextResponse.json({ error: 'User not found' }, { status: 404 });
        }
        
        // Exclude password and IP
        const { password, signupIP, ...userData } = user;

        return NextResponse.json(userData);
    } catch (e) {
        return NextResponse.json({ error: 'Failed to fetch dashboard data' }, { status: 500 });
    }
}

--- FILE: app/api/entries/add/route.ts ---

import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth';

const prisma = new PrismaClient();

export async function POST(req: Request) {
    const tokenPayload = await verifyToken();
    if (!tokenPayload) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { amount, description, roomId } = await req.json();
    const userId = tokenPayload.userId;

    if (!amount || !description || !roomId) {
        return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    try {
        const entry = await prisma.entry.create({
            data: {
                amount: parseFloat(amount),
                description,
                roomId,
                userId,
            },
        });
        return NextResponse.json(entry);
    } catch (e) {
        return NextResponse.json({ error: 'Failed to add entry' }, { status: 500 });
    }
}

--- FILE: app/api/rooms/create/route.ts ---

import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth';

const prisma = new PrismaClient();

export async function POST() {
    const tokenPayload = await verifyToken();
    if (!tokenPayload) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = tokenPayload.userId;
    const generateRoomCode = () => Math.floor(100000 + Math.random() * 900000).toString();

    let roomCode = generateRoomCode();
    let room = await prisma.room.findUnique({ where: { code: roomCode } });

    while (room) {
        roomCode = generateRoomCode();
        room = await prisma.room.findUnique({ where: { code: roomCode } });
    }

    try {
        const newRoom = await prisma.room.create({
            data: {
                code: roomCode,
                users: {
                    create: {
                        userId: userId
                    }
                }
            },
        });
        return NextResponse.json(newRoom);
    } catch (e) {
        return NextResponse.json({ error: 'Failed to create room' }, { status: 500 });
    }
}

--- FILE: app/api/rooms/join/route.ts ---

import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';
import { verifyToken } from '@/lib/auth';

const prisma = new PrismaClient();

export async function POST(req: Request) {
    const tokenPayload = await verifyToken();
    if (!tokenPayload) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { roomCode } = await req.json();
    const userId = tokenPayload.userId;

    const room = await prisma.room.findUnique({ where: { code: roomCode } });
    if (!room) {
        return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }
    
    const isUserInRoom = await prisma.usersOnRooms.findFirst({
        where: { roomId: room.id, userId: userId }
    });

    if (isUserInRoom) {
         return NextResponse.json({ error: 'Already in room' }, { status: 400 });
    }

    try {
        await prisma.usersOnRooms.create({
            data: {
                roomId: room.id,
                userId: userId,
            },
        });
        return NextResponse.json(room);
    } catch (e) {
        return NextResponse.json({ error: 'Failed to join room' }, { status: 500 });
    }
}

--- FILE: app/constants.ts ---

export const JWT_SECRET = process.env.JWT_SECRET;
export const BASE_URL = process.env.NODE_ENV === 'production' 
    ? 'https://your-production-domain.com' 
    : 'http://localhost:3000';

if (!JWT_SECRET) {
    throw new Error("JWT_SECRET is not defined in the environment variables");
}

--- FILE: app/globals.css ---

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 222.2 47.4% 11.2%;

  --muted: 210 40% 96.1%;
  --muted-foreground: 215.4 16.3% 46.9%;

  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;

  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;
  
  --destructive: 0 100% 50%;
  --destructive-foreground: 210 40% 98%;

  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 222.2 47.4% 11.2%;

  --radius: 0.5rem;
}

--- FILE: app/layout.tsx ---

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Loan Tracker",
  description: "A simple app to track loans with friends",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

--- FILE: app/page.tsx ---

import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}


--- FILE: components/AuthForm.tsx ---

'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useTranslations } from 'next-intl';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';

export default function AuthForm() {
  const [isLogin, setIsLogin] = useState(true);
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const router = useRouter();
  const t = useTranslations('AuthForm');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const url = isLogin ? '/api/auth/login' : '/api/auth/signup';
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });

    const data = await res.json();

    if (res.ok) {
      if (isLogin) {
        router.push('/dashboard');
        router.refresh();
      } else {
        setIsLogin(true);
      }
    } else {
      setError(data.error);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen">
      <Card className="w-full max-w-sm">
        <CardHeader>
          <CardTitle>{isLogin ? t('login') : t('signup')}</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            {error && <p className="text-red-500 text-sm">{error}</p>}
            <Input
              type="text"
              placeholder={t('username')}
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
            <Input
              type="password"
              placeholder={t('password')}
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <Button type="submit" className="w-full">
              {isLogin ? t('loginButton') : t('signupButton')}
            </Button>
          </form>
          <Button variant="link" onClick={() => setIsLogin(!isLogin)} className="mt-4 w-full">
            {isLogin ? t('switchToSignup') : t('switchToLogin')}
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}

--- FILE: components/DashboardClient.tsx ---

'use client';

import { useState, useEffect } from 'react';
import RoomManager from './RoomManager';
import EntryManager from './EntryManager';
import { useTranslations } from 'next-intl';

export default function DashboardClient({ initialData, lang }: { initialData: any, lang: string }) {
    const [data, setData] = useState(initialData);
    const [loading, setLoading] = useState(true);
    const t = useTranslations('Dashboard');

    useEffect(() => {
        if (initialData) {
            setData(initialData);
            setLoading(false);
        }
    }, [initialData]);

    const refreshData = async () => {
        const res = await fetch('/api/dashboard');
        const newData = await res.json();
        setData(newData);
    };

    if (loading) {
        return <div>Loading...</div>;
    }
    
    const hasRooms = data.rooms && data.rooms.length > 0;
    const isOnlyOneRoom = hasRooms && data.rooms.length === 1;

    return (
        <div className="container mx-auto p-4">
             <h1 className="text-2xl font-bold mb-4">{t('welcome', {username: data.username})}</h1>
            
            {!hasRooms && <RoomManager onRoomAction={refreshData} />}

            {isOnlyOneRoom && <EntryManager room={data.rooms[0].room} userId={data.id} onEntryAdded={refreshData} />}
            
            {hasRooms && !isOnlyOneRoom && (
                 <div>
                    {/* Here you can add logic to select a room if there are multiple */}
                    <p>You are in multiple rooms. Please select a room:</p>
                     {data.rooms.map((userRoom: any) => (
                         <div key={userRoom.room.id} className="p-4 my-2 border rounded-md">
                           <EntryManager room={userRoom.room} userId={data.id} onEntryAdded={refreshData} />
                         </div>
                     ))}
                 </div>
            )}
        </div>
    );
}

--- FILE: components/EntryManager.tsx ---

'use client';

import { useState, useMemo } from 'react';
import { useTranslations } from 'next-intl';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { ArrowDown, ArrowUp } from 'lucide-react';

// Define the type for an entry
interface Entry {
    id: string;
    amount: number;
    description: string;
    createdAt: string;
    user: {
        id: string;
        username: string;
    };
}

// Define the type for a room
interface Room {
    id: string;
    code: string;
    entries: Entry[];
    users: { user: { id: string; username: string; } }[];
}

export default function EntryManager({ room, userId, onEntryAdded }: { room: Room, userId: string, onEntryAdded: () => void }) {
    const [view, setView] = useState('add'); // 'add' or 'list'
    const [amount, setAmount] = useState('');
    const [description, setDescription] = useState('');
    const [error, setError] = useState('');
    const [detailsVisible, setDetailsVisible] = useState(false);

    const t = useTranslations('Entry');

    const handleAddEntry = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        const res = await fetch('/api/entries/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ amount, description, roomId: room.id }),
        });

        if (res.ok) {
            setAmount('');
            setDescription('');
            onEntryAdded();
        } else {
            const data = await res.json();
            setError(data.error || 'Failed to add entry');
        }
    };

    const { totalOwed, userBalances } = useMemo(() => {
        const totalPaidByUser = room.entries
            .filter(e => e.user.id === userId)
            .reduce((sum, e) => sum + e.amount, 0);

        const totalSpentInRoom = room.entries.reduce((sum, e) => sum + e.amount, 0);
        const numUsers = room.users.length;
        const userShare = numUsers > 0 ? totalSpentInRoom / numUsers : 0;

        const totalOwedToUser = totalPaidByUser - userShare;

        const otherUsers = room.users.filter(u => u.user.id !== userId);
        const balances: Record<string, number> = {};

        otherUsers.forEach(otherUser => {
            const paidByOther = room.entries
                .filter(e => e.user.id === otherUser.user.id)
                .reduce((sum, e) => sum + e.amount, 0);
            
            const debt = userShare - paidByOther;
            balances[otherUser.user.username] = debt;
        });


        return { totalOwed: totalOwedToUser, userBalances: balances };
    }, [room, userId]);

    if (view === 'list') {
        return (
            <Card>
                <CardHeader>
                    <CardTitle>{t('allEntries')}</CardTitle>
                </CardHeader>
                <CardContent>
                    <ul>
                        {room.entries.map(entry => (
                            <li key={entry.id} className="flex justify-between p-2 border-b">
                                <span>{entry.description} ({entry.user.username})</span>
                                <span>{entry.amount} ILS</span>
                            </li>
                        ))}
                    </ul>
                    <Button onClick={() => setView('add')} className="mt-4 w-full">{t('backToAddEntry')}</Button>
                </CardContent>
            </Card>
        );
    }
    
    return (
        <Card className="w-full max-w-md mx-auto">
             <CardHeader>
                <div className="flex justify-between items-center">
                    <CardTitle>{t('addEntry')}</CardTitle>
                    <div className={totalOwed >= 0 ? 'text-green-600' : 'text-red-600'}>
                        <span className="font-bold text-lg">{Math.abs(totalOwed).toFixed(2)} ILS</span>
                        <span className="text-sm ml-1">{totalOwed >= 0 ? t('oweYou') : t('youOwe')}</span>
                    </div>
                </div>
                
                 <div className="text-sm text-gray-500 flex items-center cursor-pointer" onClick={() => setDetailsVisible(!detailsVisible)}>
                     Details {detailsVisible ? <ArrowUp size={16} className="ml-1" /> : <ArrowDown size={16} className="ml-1" />}
                 </div>

                 {detailsVisible && (
                     <div className="text-xs space-y-1 mt-2 p-2 bg-gray-50 rounded">
                         {Object.entries(userBalances).map(([username, balance]) => (
                             <div key={username} className="flex justify-between">
                                 <span>{balance > 0 ? `${username} owes you` : `You owe ${username}`}</span>
                                 <span>{Math.abs(balance).toFixed(2)} ILS</span>
                             </div>
                         ))}
                     </div>
                 )}
            </CardHeader>
            <CardContent>
                <form onSubmit={handleAddEntry} className="space-y-4">
                     {error && <p className="text-red-500">{error}</p>}
                    <Input
                        type="number"
                        placeholder={t('amount')}
                        value={amount}
                        onChange={(e) => setAmount(e.target.value)}
                        required
                        step="0.01"
                    />
                    <Input
                        type="text"
                        placeholder={t('description')}
                        value={description}
                        onChange={(e) => setDescription(e.target.value)}
                        required
                    />
                    <Button type="submit" className="w-full">{t('addButton')}</Button>
                </form>
                <Button variant="outline" onClick={() => setView('list')} className="mt-4 w-full">
                    {t('viewAllEntries')}
                </Button>
            </CardContent>
        </Card>
    );
}

--- FILE: components/RoomManager.tsx ---

'use client';

import { useState } from 'react';
import { useTranslations } from 'next-intl';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';

export default function RoomManager({ onRoomAction }: { onRoomAction: () => void }) {
    const [roomCode, setRoomCode] = useState('');
    const [error, setError] = useState('');
    const t = useTranslations('Room');

    const handleCreateRoom = async () => {
        setError('');
        const res = await fetch('/api/rooms/create', { method: 'POST' });
        if (res.ok) {
            onRoomAction();
        } else {
            const data = await res.json();
            setError(data.error);
        }
    };

    const handleJoinRoom = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        const res = await fetch('/api/rooms/join', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ roomCode }),
        });
        if (res.ok) {
            onRoomAction();
        } else {
            const data = await res.json();
            setError(data.error);
        }
    };

    return (
        <Card className="w-full max-w-md mx-auto">
            <CardHeader>
                 <CardTitle>{t('joinRoom')}</CardTitle>
            </CardHeader>
            <CardContent>
                {error && <p className="text-red-500 mb-4">{error}</p>}
                <form onSubmit={handleJoinRoom} className="flex gap-2">
                    <Input 
                        type="text"
                        placeholder={t('roomCode')}
                        value={roomCode}
                        onChange={(e) => setRoomCode(e.target.value)}
                        className="flex-grow"
                    />
                    <Button type="submit">{t('joinButton')}</Button>
                </form>

                <div className="my-4 text-center">{t('or')}</div>

                <Button onClick={handleCreateRoom} variant="secondary" className="w-full">{t('createRoom')}</Button>
            </CardContent>
        </Card>
    );
}

--- FILE: components/ui/button.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

--- FILE: components/ui/card.tsx ---

import * as React from "react"
import { cn } from "@/lib/utils"

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)} {...props} />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(({ className, ...props }, ref) => (
  <h3 ref={ref} className={cn("text-2xl font-semibold leading-none tracking-tight", className)} {...props} />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(({ className, ...props }, ref) => (
  <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--- FILE: components/ui/input.tsx ---

import * as React from "react"
import { cn } from "@/lib/utils"

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Input.displayName = "Input"

export { Input }

--- FILE: i18n.ts ---

import {getRequestConfig} from 'next-intl/server';
import {notFound} from 'next/navigation';
 
const locales = ['en', 'he', 'ru'];
 
export default getRequestConfig(async ({locale}) => {
  // This is a robust check that handles two cases:
  // 1. `locale` is undefined.
  // 2. `locale` is a string but not one of our supported locales.
  // In either case, we stop rendering and show a 404 page.
  if (!locale || !locales.includes(locale)) {
    notFound();
  }
 
  // Because the only way to get past the check above is for `locale`
  // to be a valid string that exists in our `locales` array,
  // TypeScript now correctly understands that `locale` is of type `string`.
  return {
    locale,
    messages: (await import(`./locales/${locale}.json`)).default
  };
});

--- FILE: lib/auth.ts ---

import { jwtVerify } from 'jose';
import { cookies } from 'next/headers';
import { JWT_SECRET } from '@/app/constants';

export async function verifyToken() {
    const token = (await cookies()).get('token')?.value;

    if (!token) {
        return null;
    }

    try {
        const secret = new TextEncoder().encode(JWT_SECRET);
        const { payload } = await jwtVerify(token, secret);
        return payload as { userId: string, iat: number, exp: number };
    } catch (e) {
        return null;
    }
}

--- FILE: lib/utils.ts ---

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- FILE: locales/en.json ---

{
  "AuthForm": {
    "login": "Login",
    "signup": "Sign Up",
    "username": "Username",
    "password": "Password",
    "loginButton": "Login",
    "signupButton": "Sign Up",
    "switchToSignup": "Don't have an account? Sign Up",
    "switchToLogin": "Already have an account? Login"
  },
  "Room": {
    "createRoom": "Create Room",
    "joinRoom": "Join Room",
    "createButton": "Create",
    "joinButton": "Join",
    "roomCode": "Room Code",
    "or": "or"
  },
  "Entry": {
    "addEntry": "Add Entry",
    "amount": "Amount (ILS)",
    "description": "Description",
    "addButton": "Add",
    "viewAllEntries": "View All Entries",
    "allEntries": "All Entries",
    "oweYou": "Owe You",
    "youOwe": "You Owe",
    "backToAddEntry": "Back to Add Entry"
  },
  "Dashboard": {
    "welcome": "Welcome, {username}"
  },
  "Errors": {
    "ipAlreadyRegistered": "This IP address has already been used to sign up.",
    "userExists": "User already exists.",
    "invalidCredentials": "Invalid username or password.",
    "roomNotFound": "Room not found.",
    "alreadyInRoom": "You are already in this room.",
    "failedToCreateRoom": "Failed to create room.",
    "failedToJoinRoom": "Failed to join room.",
    "failedToAddEntry": "Failed to add entry.",
    "unauthorized": "Unauthorized."
  }
}

--- FILE: locales/he.json ---

{
  "AuthForm": {
    "login": "התחברות",
    "signup": "הרשמה",
    "username": "שם משתמש",
    "password": "סיסמה",
    "loginButton": "התחבר",
    "signupButton": "הירשם",
    "switchToSignup": "אין לך חשבון? הירשם",
    "switchToLogin": "יש לך כבר חשבון? התחבר"
  },
  "Room": {
    "createRoom": "צור חדר",
    "joinRoom": "הצטרף לחדר",
    "createButton": "צור",
    "joinButton": "הצטרף",
    "roomCode": "קוד חדר",
    "or": "או"
  },
  "Entry": {
    "addEntry": "הוסף רשומה",
    "amount": "סכום (ש\"ח)",
    "description": "תיאור",
    "addButton": "הוסף",
    "viewAllEntries": "צפה בכל הרשומות",
    "allEntries": "כל הרשומות",
    "oweYou": "חייבים לך",
    "youOwe": "אתה חייב",
    "backToAddEntry": "חזור להוספת רשומה"
  },
  "Dashboard": {
    "welcome": "ברוך הבא, {username}"
  },
  "Errors": {
    "ipAlreadyRegistered": "כתובת ה-IP הזו כבר שימשה להרשמה.",
    "userExists": "המשתמש כבר קיים.",
    "invalidCredentials": "שם משתמש או סיסמה שגויים.",
    "roomNotFound": "החדר לא נמצא.",
    "alreadyInRoom": "אתה כבר נמצא בחדר הזה.",
    "failedToCreateRoom": "יצירת החדר נכשלה.",
    "failedToJoinRoom": "ההצטרפות לחדר נכשלה.",
    "failedToAddEntry": "הוספת הרשומה נכשלה.",
    "unauthorized": "לא מורשה."
  }
}

--- FILE: locales/ru.json ---

{
  "AuthForm": {
    "login": "Вход",
    "signup": "Регистрация",
    "username": "Имя пользователя",
    "password": "Пароль",
    "loginButton": "Войти",
    "signupButton": "Зарегистрироваться",
    "switchToSignup": "Нет аккаунта? Зарегистрируйтесь",
    "switchToLogin": "Уже есть аккаунт? Войдите"
  },
  "Room": {
    "createRoom": "Создать комнату",
    "joinRoom": "Присоединиться к комнате",
    "createButton": "Создать",
    "joinButton": "Присоединиться",
    "roomCode": "Код комнаты",
    "or": "или"
  },
  "Entry": {
    "addEntry": "Добавить запись",
    "amount": "Сумма (ILS)",
    "description": "Описание",
    "addButton": "Добавить",
    "viewAllEntries": "Посмотреть все записи",
    "allEntries": "Все записи",
    "oweYou": "Вам должны",
    "youOwe": "Вы должны",
    "backToAddEntry": "Вернуться к добавлению записи"
  },
  "Dashboard": {
    "welcome": "Добро пожаловать, {username}"
  },
  "Errors": {
    "ipAlreadyRegistered": "Этот IP-адрес уже использовался для регистрации.",
    "userExists": "Пользователь уже существует.",
    "invalidCredentials": "Неверное имя пользователя или пароль.",
    "roomNotFound": "Комната не найдена.",
    "alreadyInRoom": "Вы уже в этой комнате.",
    "failedToCreateRoom": "Не удалось создать комнату.",
    "failedToJoinRoom": "Не удалось присоединиться к комнате.",
    "failedToAddEntry": "Не удалось добавить запись.",
    "unauthorized": "Не авторизован."
  }
}

--- FILE: middleware.ts ---

import createMiddleware from 'next-intl/middleware';

export default createMiddleware({
  locales: ['en', 'he', 'ru'],
  defaultLocale: 'en'
});

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']
};

--- FILE: package.json ---

{
  "name": "my-loan-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@prisma/client": "^6.10.1",
    "@radix-ui/react-slot": "^1.2.3",
    "bcrypt": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "jose": "^6.0.11",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.518.0",
    "next": "15.3.4",
    "next-intl": "^4.1.0",
    "prisma": "^6.10.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.3.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/bcrypt": "^5.0.2",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


--- FILE: prisma/schema.prisma ---

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  password  String
  createdAt DateTime @default(now())
  signupIP  String?
  rooms     UsersOnRooms[]
  entries   Entry[]
}

model Room {
  id        String   @id @default(cuid())
  code      String   @unique
  createdAt DateTime @default(now())
  users     UsersOnRooms[]
  entries   Entry[]
}

model UsersOnRooms {
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  room      Room     @relation(fields: [roomId], references: [id])
  roomId    String
  assignedAt DateTime @default(now())

  @@id([userId, roomId])
}

model Entry {
  id          String   @id @default(cuid())
  amount      Float
  description String
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  room        Room     @relation(fields: [roomId], references: [id])
  roomId      String
}

--- FILE: tailwind.config.ts ---

import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
      },
      borderRadius: {
        lg: `var(--radius)`,
        md: `calc(var(--radius) - 2px)`,
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [],
};
export default config;

